<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Class Schedule - Test (fixed)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Poppins', sans-serif; background-color:#F0F4F8; }
    /* (kept your CSS unchanged for brevity — you can paste your original styles here) */
    .btn { background:#4A90E2;color:#fff;padding:.75rem 1.25rem;border-radius:.5rem;border:none;cursor:pointer }
    .loader { border:4px solid #f3f3f3;border-top:4px solid #4A90E2;border-radius:50%;width:36px;height:36px;animation:spin 1s linear infinite;margin:1rem auto; }
    @keyframes spin { to { transform:rotate(360deg); } }
  </style>
</head>
<body>
  <div class="container mx-auto p-6 max-w-4xl">
    <h1 class="text-2xl font-bold mb-4">Class Schedule — Test (fixed)</h1>
    <p id="connectionStatus" class="text-gray-500 mb-4">Connecting...</p>

    <div>
      <input id="subjectSearchInput" class="p-3 border rounded w-full mb-2" placeholder="Search and add subject...">
      <div id="searchResults" class="hidden border bg-white"></div>
      <div id="selectedTagsContainer" class="flex gap-2 mt-2"></div>
    </div>

    <div class="mt-4">
      <button id="syncToGoogleBtn" class="btn mr-2">Sync to Google Calendar</button>
      <button id="downloadMonthBtn" class="btn" style="background:green">Download Outlook/Google Calendar File</button>
    </div>

    <div id="todayClasses" class="mt-6"><div class="loader"></div></div>
    <div id="upcomingClassesContainer" class="mt-6"><div class="loader"></div></div>

    <div style="margin-top:36px">
      <button id="refreshBtn" class="btn">Refresh Data</button>
    </div>
  </div>

  <!-- Google identity library -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>

  <script>
  // --------------- CONFIG ---------------
  // Replace this with your Google OAuth Client ID
  const CLIENT_ID = 'YOUR_CLIENT_ID.apps.googleusercontent.com';
  const SCOPE = 'https://www.googleapis.com/auth/calendar.events';
  const APP_EXT_PROP_KEY = 'studentdashboard_id';
  const APP_OWNER_FLAG = 'studentdashboard_owner';

  // Sheets API URL (your public spreadsheet values endpoint)
  const API_URL = 'https://sheets.googleapis.com/v4/spreadsheets/1386awb-Qw-_ld03zlXFNfkkHi7N9XY4LwirxQtkMpZk/values/New!A1:N1300?key=AIzaSyBQps5D4hUe8owgZOe4-qgFwoXwl5x6ATo';

  // --------------- STATE ---------------
  let allSheetData = [];       // loaded sheet rows as arrays
  let enrolledClasses = [];    // user-selected subjects
  let tokenResponse = null;
  let pendingSyncFunction = null;

  // --------------- UTIL: date & time parsing ---------------
  function pad2(n){ return (n<10? '0'+n : ''+n); }

  // parseDate robustly: prefer DD/MM/YYYY (sheet likely uses day-first)
  function parseDate(dateString) {
    if (!dateString) return null;
    const s = String(dateString).trim();
    // Accept common separators
    if (s.includes('/')) {
      const parts = s.split('/').map(p => p.trim());
      if (parts.length === 3) {
        let a = parseInt(parts[0],10), b = parseInt(parts[1],10), c = parseInt(parts[2],10);
        if (isNaN(a)||isNaN(b)||isNaN(c)) return null;
        // heuristics: if first part > 12 => day-first (DD/MM/YYYY)
        if (a > 12) {
          const day = a, month = b, year = (c < 100 ? 2000 + c : c);
          return new Date(year, month -1, day);
        }
        // else ambiguous: if second part > 12 treat it as DD/MM; else assume DD/MM as sheet is day-first
        if (b > 12) {
          const day = a, month = b, year = (c < 100 ? 2000 + c : c);
          return new Date(year, month -1, day);
        }
        // default to day-first (DD/MM/YYYY)
        const day = a, month = b, year = (c < 100 ? 2000 + c : c);
        return new Date(year, month -1, day);
      }
    }
    // fallback parse
    const d = new Date(s);
    return isNaN(d.getTime()) ? null : d;
  }

  // parse times like "15:00", "3:30 PM", "3pm", "03:00"
  function parseTimeString(tstr) {
    if (!tstr) return null;
    const s = String(tstr).trim().toLowerCase();
    // Normalize
    let norm = s.replace(/\./g, ':').replace(/\s+/g,' ');
    // handle 24hr hh:mm
    let m = norm.match(/(\d{1,2})(?::(\d{2}))?\s*(am|pm)?/i);
    if (!m) return null;
    let hh = parseInt(m[1],10);
    let mm = m[2] ? parseInt(m[2],10) : 0;
    let ap = m[3];
    if (ap) {
      ap = ap.toLowerCase();
      if (ap === 'pm' && hh < 12) hh += 12;
      if (ap === 'am' && hh === 12) hh = 0;
    }
    return { hours: hh, minutes: mm };
  }

  function toRFC3339_Kolkata(dateObj) {
    // produce RFC3339 with +05:30
    const yyyy = dateObj.getFullYear();
    const mm = pad2(dateObj.getMonth()+1);
    const dd = pad2(dateObj.getDate());
    const hh = pad2(dateObj.getHours());
    const min = pad2(dateObj.getMinutes());
    return `${yyyy}-${mm}-${dd}T${hh}:${min}:00+05:30`;
  }

  // --------------- UI Helpers ---------------
  function showToast(msg, type='success') {
    const el = document.createElement('div');
    el.textContent = msg;
    el.style.position = 'fixed';
    el.style.top = '20px';
    el.style.right = '20px';
    el.style.padding = '10px 14px';
    el.style.zIndex = 9999;
    el.style.background = type === 'success' ? '#22c55e' : '#ef4444';
    el.style.color = 'white';
    el.style.borderRadius = '8px';
    document.body.appendChild(el);
    setTimeout(()=> el.remove(), 3500);
  }

  // --------------- Sheet fetch & render ---------------
  async function refreshData() {
    document.getElementById('connectionStatus').textContent = 'Loading spreadsheet...';
    try {
      const res = await fetch(API_URL);
      if (!res.ok) throw new Error('Sheet fetch failed: ' + res.status);
      const json = await res.json();
      allSheetData = json.values || [];
      document.getElementById('connectionStatus').textContent = 'Spreadsheet loaded';
      renderTodayTomorrow();
      populateMasterClassList();
    } catch (err) {
      console.error(err);
      document.getElementById('connectionStatus').textContent = '⚠️ Connection failed';
      showToast('Failed to load sheet: ' + err.message, 'error');
    }
  }

  function populateMasterClassList() {
    // Build class dropdown/search data from column 10 (index 9) as your original code did
    const unique = new Set();
    for (let i=1;i<allSheetData.length;i++){
      const row = allSheetData[i];
      if (row && row[9]) unique.add(row[9].toString().trim());
    }
    const list = Array.from(unique).sort();
    // simple rendering into selectedTags container if user already picked
    const tagsContainer = document.getElementById('selectedTagsContainer');
    tagsContainer.innerHTML = enrolledClasses.map(s => `<div style="background:#3b82f6;color:white;padding:6px 10px;border-radius:999px">${s}</div>`).join('');
    // also attach search logic
    const input = document.getElementById('subjectSearchInput');
    const results = document.getElementById('searchResults');
    input.addEventListener('input', () => {
      const q = input.value.toLowerCase().trim();
      if (!q) { results.classList.add('hidden'); results.innerHTML=''; return; }
      const filtered = list.filter(x => x.toLowerCase().includes(q) && !enrolledClasses.includes(x)).slice(0,20);
      results.innerHTML = filtered.map(x => `<div class="p-2 cursor-pointer" data-val="${x}">${x}</div>`).join('') || '<div class="p-2 text-sm text-gray-500">No matches</div>';
      results.classList.remove('hidden');
    });
    results.addEventListener('click', e => {
      const t = e.target.closest('[data-val]');
      if (!t) return;
      enrolledClasses.push(t.dataset.val);
      enrolledClasses.sort();
      input.value = '';
      results.classList.add('hidden');
      populateMasterClassList();
      showToast('Added subject: ' + t.dataset.val);
    });
  }

  function renderTodayTomorrow() {
    const today = new Date(), tomorrow = new Date(); tomorrow.setDate(today.getDate()+1);
    renderClassesForDate(today, 'todayClasses');
    renderClassesForDate(tomorrow, 'upcomingClassesContainer');
  }

  function isSameDay(a,b) { return a && b && a.getFullYear()===b.getFullYear() && a.getMonth()===b.getMonth() && a.getDate()===b.getDate(); }

  function renderClassesForDate(date, containerId) {
    const container = document.getElementById(containerId);
    const rows = [];
    for (let i=1;i<allSheetData.length;i++){
      const row = allSheetData[i];
      if (!row || !row[0] || !row[1] || !row[2]) continue;
      const d = parseDate(row[0]);
      if (!d || !isSameDay(d, date)) continue;
      const className = (row[2]||'').toString().trim();
      if (enrolledClasses.length>0 && !enrolledClasses.some(s => className.toLowerCase().includes(s.toLowerCase()))) continue;
      rows.push({ class: className, time: row[1], location: row[4] || '', professor: row[6] || 'N/A' });
    }
    if (rows.length === 0) container.innerHTML = '<p class="text-gray-500 p-4">No classes</p>';
    else container.innerHTML = rows.map(r => `<div style="background:white;padding:10px;border-radius:8px;margin-bottom:6px"><strong>${r.class}</strong><div>${r.time} • ${r.location} • Prof: ${r.professor}</div></div>`).join('');
  }

  // --------------- ICS generator (keeps UI same) ---------------
  function generateMonthlyICS() {
    if (enrolledClasses.length === 0) { showToast('Select subjects first', 'error'); return; }
    const termStart = new Date(2025,8,10), termEnd = new Date(2025,11,6);
    let ics = [
      'BEGIN:VCALENDAR',
      'VERSION:2.0',
      'PRODID:-//StudentDashboard//AkshaySharma//EN',
      'CALSCALE:GREGORIAN',
      'METHOD:PUBLISH',
      'BEGIN:VTIMEZONE',
      'TZID:Asia/Kolkata',
      'BEGIN:STANDARD',
      'DTSTART:19700101T000000',
      'TZOFFSETFROM:+0530',
      'TZOFFSETTO:+0530',
      'TZNAME:IST',
      'END:STANDARD',
      'END:VTIMEZONE'
    ].join('\r\n') + '\r\n';

    let count = 0;
    for (let i=1;i<allSheetData.length;i++){
      const row = allSheetData[i];
      if (!row || !row[0] || !row[1] || !row[2]) continue;
      const classDate = parseDate(row[0]);
      if (!classDate) continue;
      if (classDate < termStart || classDate > termEnd) continue;
      const className = (row[2]||'').toString().trim();
      if (enrolledClasses.length>0 && !enrolledClasses.some(s => className.toLowerCase().includes(s.toLowerCase()))) continue;

      const timeParts = (row[1]||'').split(/[-–—\u2013\u2014]|to/i).map(s => s.trim()).filter(Boolean);
      if (timeParts.length<2) continue;
      const startT = parseTimeString(timeParts[0]);
      const endT = parseTimeString(timeParts[1]);
      if (!startT || !endT) continue;

      const startDate = new Date(classDate.getFullYear(), classDate.getMonth(), classDate.getDate(), startT.hours, startT.minutes);
      const endDate   = new Date(classDate.getFullYear(), classDate.getMonth(), classDate.getDate(), endT.hours, endT.minutes);
      if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) continue;

      // Stable UID: prefer an existing rowNN cell, else fallback to row index + subject
      let stable = null;
      for (const c of row) {
        if (typeof c === 'string' && /^row\d+/i.test(c.trim())) { stable = c.trim(); break; }
      }
      const uid = stable ? `${stable}@studentdashboard.com` : `r${i}-${className.replace(/\s+/g,'') }@studentdashboard.com`;

      const vevent = [
        'BEGIN:VEVENT',
        `DTSTAMP:${new Date().toISOString().replace(/[-:.]/g,'').slice(0,-4)}Z`,
        `UID:${uid}`,
        `DTSTART;TZID=Asia/Kolkata:${startDate.getFullYear()}${pad2(startDate.getMonth()+1)}${pad2(startDate.getDate())}T${pad2(startDate.getHours())}${pad2(startDate.getMinutes())}00`,
        `DTEND;TZID=Asia/Kolkata:${endDate.getFullYear()}${pad2(endDate.getMonth()+1)}${pad2(endDate.getDate())}T${pad2(endDate.getHours())}${pad2(endDate.getMinutes())}00`,
        `SUMMARY:${className}`,
        `DESCRIPTION:Professor: ${row[6] ? row[6] : 'N/A'}`,
        `LOCATION:${row[4] ? row[4] : ''}`,
        'END:VEVENT'
      ].join('\r\n') + '\r\n';

      ics += vevent;
      count++;
    }

    ics += 'END:VCALENDAR';

    if (count === 0) { showToast('No classes found for selected subjects', 'error'); return; }

    const blob = new Blob([ics], { type: 'text/calendar;charset=utf-8' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'class_schedule.ics';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(a.href);
    showToast(`Generated ICS with ${count} events`);
  }

  // --------------- Google Calendar Sync code (client-side upsert) ---------------
  // We'll use Google Identity Services token client and Calendar REST API.
  let tokenClient = null;

  function initTokenClient() {
    if (!window.google || !google.accounts || !google.accounts.oauth2) {
      console.warn('Google Identity library not loaded yet.');
      return;
    }
    tokenClient = google.accounts.oauth2.initTokenClient({
      client_id: CLIENT_ID,
      scope: SCOPE,
      callback: (resp) => {
        tokenResponse = resp;
        console.log('Got token response', resp);
        if (pendingSyncFunction) {
          const f = pendingSyncFunction;
          pendingSyncFunction = null;
          f();
        }
      }
    });
  }

  function requestGoogleToken() {
    if (!tokenClient) initTokenClient();
    tokenClient.requestAccessToken({ prompt: 'consent' });
  }

  async function gcalFetch(url, method='GET', body=null) {
    if (!tokenResponse || !tokenResponse.access_token) throw new Error('No OAuth token; request access first');
    const headers = { Authorization: 'Bearer ' + tokenResponse.access_token };
    const opts = { method, headers };
    if (body) { headers['Content-Type'] = 'application/json'; opts.body = JSON.stringify(body); }
    const r = await fetch(url, opts);
    if (!r.ok) {
      const text = await r.text();
      throw new Error(`GCal API ${r.status}: ${text}`);
    }
    if (r.status === 204) return {};
    return await r.json();
  }

  async function listMyEvents(timeMin, timeMax, pageToken=null) {
    const params = new URLSearchParams({ singleEvents: 'true', maxResults: '2500', orderBy: 'startTime' });
    if (timeMin) params.set('timeMin', timeMin);
    if (timeMax) params.set('timeMax', timeMax);
    params.set('privateExtendedProperty', encodeURIComponent(`${APP_OWNER_FLAG}=true`));
    if (pageToken) params.set('pageToken', pageToken);
    const url = `https://www.googleapis.com/calendar/v3/calendars/primary/events?${params.toString()}`;
    return await gcalFetch(url, 'GET');
  }

  async function findEventByExternalId(externalId) {
    const param = encodeURIComponent(`${APP_EXT_PROP_KEY}=${externalId}`);
    const url = `https://www.googleapis.com/calendar/v3/calendars/primary/events?privateExtendedProperty=${param}&singleEvents=true&maxResults=1`;
    const res = await gcalFetch(url, 'GET');
    return (res.items && res.items.length) ? res.items[0] : null;
  }

  async function createEventOnGoogle(event) {
    const body = {
      summary: event.summary,
      description: event.description || '',
      location: event.location || '',
      start: { dateTime: event.startRfc3339 },
      end:   { dateTime: event.endRfc3339 },
      extendedProperties: { private: { [APP_EXT_PROP_KEY]: event.externalId, [APP_OWNER_FLAG]: 'true' } }
    };
    return await gcalFetch('https://www.googleapis.com/calendar/v3/calendars/primary/events', 'POST', body);
  }

  async function updateEventOnGoogle(eventId, event) {
    const body = {
      summary: event.summary,
      description: event.description || '',
      location: event.location || '',
      start: { dateTime: event.startRfc3339 },
      end:   { dateTime: event.endRfc3339 },
      extendedProperties: { private: { [APP_EXT_PROP_KEY]: event.externalId, [APP_OWNER_FLAG]: 'true' } }
    };
    return await gcalFetch(`https://www.googleapis.com/calendar/v3/calendars/primary/events/${eventId}`, 'PATCH', body);
  }

  async function deleteEventOnGoogle(eventId) {
    return await gcalFetch(`https://www.googleapis.com/calendar/v3/calendars/primary/events/${eventId}`, 'DELETE');
  }

  function rowToEvent(row, rowIndex) {
    // columns: date row[0], time row[1], subject row[2], location row[4], professor row[6]
    const rawDate = row[0], rawTime = row[1];
    const subjectCandidates = [row[2], row[9], row[10], row[11], row[3]];
    let className = null;
    for (const c of subjectCandidates) { if (c && String(c).trim()) { className = String(c).trim(); break; } }
    if (!rawDate || !rawTime || !className) return null;
    const dateObj = parseDate(rawDate);
    if (!dateObj) return null;
    const timeParts = String(rawTime).split(/[-–—\u2013\u2014]|to/i).map(s => s.trim()).filter(Boolean);
    if (timeParts.length < 2) return null;
    const startT = parseTimeString(timeParts[0]), endT = parseTimeString(timeParts[1]);
    if (!startT || !endT) return null;
    const startDate = new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate(), startT.hours, startT.minutes);
    const endDate   = new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate(), endT.hours, endT.minutes);
    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) return null;
    // stable external id: prefer rowNN cell if available
    let stable = null;
    for (const cell of row) {
      if (typeof cell === 'string' && /^row\d+/i.test(cell.trim())) { stable = cell.trim(); break; }
    }
    const externalId = stable ? stable : `r${rowIndex}-${className.replace(/\s+/g,'_').replace(/[^\w\-]/g,'').slice(0,40)}`;
    return {
      externalId,
      summary: className,
      description: `Professor: ${row[6] ? row[6] : 'N/A'}`,
      location: (row[4] || '').toString(),
      startRfc3339: toRFC3339_Kolkata(startDate),
      endRfc3339: toRFC3339_Kolkata(endDate)
    };
  }

  async function syncAllEventsToGoogle() {
    try {
      if (!tokenResponse || !tokenResponse.access_token) {
        pendingSyncFunction = syncAllEventsToGoogle;
        requestGoogleToken();
        return;
      }

      const localEvents = [];
      for (let i=1;i<allSheetData.length;i++){
        const ev = rowToEvent(allSheetData[i], i);
        if (!ev) continue;
        // match enrolled classes if set
        if (enrolledClasses.length > 0) {
          const cn = ev.summary.toLowerCase();
          if (!enrolledClasses.some(s => cn.includes(s.toLowerCase()))) continue;
        }
        localEvents.push(ev);
      }

      if (localEvents.length === 0) { alert('No events found to sync.'); return; }
      const minTime = localEvents.map(e=>e.startRfc3339).reduce((a,b)=> a<b?a:b);
      const maxTime = localEvents.map(e=>e.endRfc3339).reduce((a,b)=> a>b?a:b);

      let remoteEvents = [];
      let pageToken = null;
      do {
        const res = await listMyEvents(minTime, maxTime, pageToken);
        if (res.items && res.items.length) remoteEvents = remoteEvents.concat(res.items);
        pageToken = res.nextPageToken || null;
      } while (pageToken);

      const remoteMap = {};
      remoteEvents.forEach(ev => {
        const ext = ev.extendedProperties && ev.extendedProperties.private && ev.extendedProperties.private[APP_EXT_PROP_KEY];
        if (ext) remoteMap[ext] = ev;
      });

      const processed = new Set();
      for (const localEvent of localEvents) {
        const existing = remoteMap[localEvent.externalId];
        if (existing) {
          await updateEventOnGoogle(existing.id, localEvent);
          console.log('Updated', localEvent.externalId);
        } else {
          await createEventOnGoogle(localEvent);
          console.log('Created', localEvent.externalId);
        }
        processed.add(localEvent.externalId);
        await new Promise(r => setTimeout(r, 150));
      }

      for (const ext in remoteMap) {
        if (!processed.has(ext)) {
          await deleteEventOnGoogle(remoteMap[ext].id);
          console.log('Deleted remote leftover', ext);
          await new Promise(r => setTimeout(r, 100));
        }
      }

      alert('Sync completed!');
    } catch (err) {
      console.error('Sync error', err);
      alert('Sync failed: ' + (err.message || err));
    }
  }

  // --------------- wiring & init ---------------
  document.getElementById('refreshBtn').addEventListener('click', refreshData);
  document.getElementById('downloadMonthBtn').addEventListener('click', generateMonthlyICS);
  document.getElementById('syncToGoogleBtn').addEventListener('click', syncAllEventsToGoogle);

  // init google token client once the library has loaded (poll quickly)
  const gLoadInterval = setInterval(() => {
    if (window.google && google.accounts && google.accounts.oauth2) {
      clearInterval(gLoadInterval);
      initTokenClient();
    }
  }, 200);

  // initial sheet fetch
  refreshData();
  </script>
</body>
</html>
