<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Class Schedule — Search Fixed</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Poppins', sans-serif; background-color:#F0F4F8; }
    .btn { background:#4A90E2;color:#fff;padding:.6rem 1rem;border-radius:.5rem;border:none;cursor:pointer; font-weight:600; }
    .btn.secondary { background:#e5e7eb; color:#111827; }
    .search-results { position:absolute; z-index:40; background:#fff; border:1px solid #e5e7eb; border-top:0; width:100%; max-height:260px; overflow:auto; box-shadow:0 6px 18px rgba(0,0,0,0.06); }
    .search-result-item { padding:10px 12px; cursor:pointer; }
    .search-result-item:hover { background:#f3f4f6; }
    .tag { background:#2563eb; color:#fff; padding:6px 10px; border-radius:999px; display:inline-flex; gap:8px; align-items:center; margin:4px; font-weight:600; }
    .tag button { background:transparent; border:0; color:#fff; cursor:pointer; font-weight:700; }
    .loader { border:4px solid #f3f3f3; border-top:4px solid #4A90E2; border-radius:50%; width:36px; height:36px; animation:spin 1s linear infinite; margin:16px auto; }
    @keyframes spin { to { transform:rotate(360deg);} }
    .hidden { display:none; }
    .card { background:white; padding:16px; border-radius:12px; box-shadow:0 8px 20px rgba(0,0,0,0.04); border:1px solid #e6edf3; }
  </style>
</head>
<body class="p-6">
  <div class="max-w-3xl mx-auto">
    <h1 class="text-2xl font-bold mb-4">Class Schedule — Test (search fixed)</h1>
    <p id="connectionStatus" class="text-gray-500 mb-4">Connecting to sheet…</p>

    <div class="card mb-4">
      <label class="block mb-2 font-semibold">Search and add a subject</label>
      <div style="position:relative;">
        <input id="subjectSearchInput" type="text" placeholder="Type subject (e.g. FE, SF)..." class="w-full p-3 border rounded-md" autocomplete="off" />
        <div id="searchResults" class="search-results hidden" role="listbox" aria-label="Search results"></div>
      </div>
      <div id="selectedTagsContainer" style="margin-top:12px;"></div>
    </div>

    <div class="flex gap-3 mb-6">
      <button id="downloadMonthBtn" class="btn secondary" disabled>Download Outlook/Google Calendar File</button>
      <button id="syncToGoogleBtn" class="btn" disabled>Sync to Google Calendar</button>
      <button id="refreshBtn" class="btn secondary">Refresh Data</button>
    </div>

    <div id="todayClasses" class="card mb-4"><div class="loader"></div></div>
    <div id="upcomingClassesContainer" class="card"><div class="loader"></div></div>
  </div>

  <!-- Google Identity (only needed if you test Sync) -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>

  <script>
  (function(){
    // ---------------- CONFIG ----------------
    const CLIENT_ID = 'YOUR_CLIENT_ID.apps.googleusercontent.com'; // replace with your own client id for Google Sync
    const SCOPE = 'https://www.googleapis.com/auth/calendar.events';
    const API_URL = 'https://sheets.googleapis.com/v4/spreadsheets/1386awb-Qw-_ld03zlXFNfkkHi7N9XY4LwirxQtkMpZk/values/New!A1:N1300?key=AIzaSyBQps5D4hUe8owgZOe4-qgFwoXwl5x6ATo';

    // ---------------- state ----------------
    let allSheetData = [];     // raw sheet value arrays
    let allClasses = [];       // deduped subject list available for search
    let enrolledClasses = [];  // user selected subjects (tags)
    let tokenResponse = null;
    let tokenClient = null;
    let pendingSyncFunction = null;

    // ---------------- small helpers ----------------
    const q = (sel) => document.querySelector(sel);
    const qa = (sel) => Array.from(document.querySelectorAll(sel));
    function escapeHtml(s){ return String(s || '').replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }
    function pad2(n){ return (n<10? '0'+n : ''+n); }

    // ---------------- parsing helpers (robust) ----------------
    function parseDate(dateString) {
      if(!dateString) return null;
      const s = String(dateString).trim();
      if (s.includes('/')) {
        const parts = s.split('/').map(p => p.trim());
        if (parts.length === 3) {
          let a=parseInt(parts[0],10), b=parseInt(parts[1],10), c=parseInt(parts[2],10);
          if (isNaN(a)||isNaN(b)||isNaN(c)) return null;
          if (a>12) { const day=a, month=b, year=(c<100?2000+c:c); return new Date(year, month-1, day); }
          // default to day-first for this sheet
          const day=a, month=b, year=(c<100?2000+c:c);
          return new Date(year, month-1, day);
        }
      }
      const d = new Date(s);
      return isNaN(d.getTime()) ? null : d;
    }
    function parseTimeString(tstr) {
      if(!tstr) return null;
      const s = String(tstr).trim().toLowerCase().replace(/\./g,':').replace(/\s+/g,' ');
      const m = s.match(/(\d{1,2})(?::|:)?(\d{2})?\s*(am|pm)?/i);
      if(!m) return null;
      let hh = parseInt(m[1],10);
      let mm = m[2] ? parseInt(m[2],10) : 0;
      const ap = m[3];
      if (ap) {
        if (ap.toLowerCase() === 'pm' && hh < 12) hh += 12;
        if (ap.toLowerCase() === 'am' && hh === 12) hh = 0;
      }
      return { hours: hh, minutes: mm };
    }
    function toRFC3339_Kolkata(dateObj) {
      const yyyy = dateObj.getFullYear();
      const mm = pad2(dateObj.getMonth()+1);
      const dd = pad2(dateObj.getDate());
      const hh = pad2(dateObj.getHours());
      const min = pad2(dateObj.getMinutes());
      return `${yyyy}-${mm}-${dd}T${hh}:${min}:00+05:30`;
    }

    // ---------------- UI: search + tags ----------------
    const searchInput = q('#subjectSearchInput');
    const resultsEl = q('#searchResults');
    const tagsContainer = q('#selectedTagsContainer');
    const downloadBtn = q('#downloadMonthBtn');
    const syncBtn = q('#syncToGoogleBtn');
    const refreshBtn = q('#refreshBtn');

    function buildAllClassesFromSheet() {
      // check multiple candidate columns in each row for subject names
      const candidates = new Set();
      for (let i=1; i<allSheetData.length; i++){
        const row = allSheetData[i] || [];
        // candidate columns (0-based): [2,9,10,11,3] like we used earlier
        [2,9,10,11,3].forEach(idx => {
          const v = row[idx];
          if (v && String(v).trim()) candidates.add(String(v).trim());
        });
      }
      allClasses = Array.from(candidates).sort((a,b)=> a.localeCompare(b));
    }

    function showSearchResults(list) {
      if (!list || list.length === 0) {
        resultsEl.innerHTML = '<div class="p-2 text-sm text-gray-500">No matches</div>';
        resultsEl.classList.remove('hidden');
        return;
      }
      resultsEl.innerHTML = list.map(item => `<div class="search-result-item" data-val="${escapeHtml(item)}">${escapeHtml(item)}</div>`).join('');
      resultsEl.classList.remove('hidden');
    }

    function updateTagsUI() {
      tagsContainer.innerHTML = enrolledClasses.map(s => {
        return `<span class="tag" data-sub="${escapeHtml(s)}">${escapeHtml(s)} <button aria-label="remove" class="remove-tag" data-sub="${escapeHtml(s)}">&times;</button></span>`;
      }).join('') || '<div class="text-gray-500">No subjects selected</div>';
      // toggle buttons
      const enabled = enrolledClasses.length > 0;
      downloadBtn.disabled = !enabled;
      syncBtn.disabled = !enabled;
      downloadBtn.classList.toggle('btn', enabled);
      syncBtn.classList.toggle('btn', enabled);
    }

    // click handler for result items
    resultsEl.addEventListener('click', (ev) => {
      const item = ev.target.closest('[data-val]');
      if (!item) return;
      const val = item.getAttribute('data-val');
      if (!val) return;
      if (!enrolledClasses.includes(val)) {
        enrolledClasses.push(val);
        enrolledClasses.sort((a,b)=>a.localeCompare(b));
      }
      searchInput.value = '';
      resultsEl.classList.add('hidden');
      updateTagsUI();
      renderTodayTomorrow(); // update classes panels immediately
    });

    // remove tag
    tagsContainer.addEventListener('click', (ev) => {
      const btn = ev.target.closest('.remove-tag');
      if (!btn) return;
      const sub = btn.getAttribute('data-sub');
      enrolledClasses = enrolledClasses.filter(x => x !== sub);
      updateTagsUI();
      renderTodayTomorrow();
    });

    // input typing -> filter
    searchInput.addEventListener('input', (e) => {
      const qstr = e.target.value.trim().toLowerCase();
      if (!qstr) { resultsEl.classList.add('hidden'); resultsEl.innerHTML=''; return; }
      const filtered = allClasses.filter(x => x.toLowerCase().includes(qstr) && !enrolledClasses.includes(x)).slice(0,50);
      showSearchResults(filtered);
    });

    // hide on outside click
    document.addEventListener('click', (ev) => {
      if (!ev.target.closest('#subjectSearchInput') && !ev.target.closest('#searchResults')) {
        resultsEl.classList.add('hidden');
      }
    });

    // ---------------- Sheet fetch & rendering ----------------
    async function refreshData() {
      q('#connectionStatus').textContent = 'Loading spreadsheet...';
      try {
        const res = await fetch(API_URL);
        if (!res.ok) throw new Error('Sheet fetch failed: ' + res.status);
        const json = await res.json();
        allSheetData = json.values || [];
        buildAllClassesFromSheet();
        q('#connectionStatus').textContent = 'Spreadsheet loaded — ' + (allClasses.length) + ' subjects detected';
        updateTagsUI();
        renderTodayTomorrow();
      } catch (err) {
        console.error(err);
        q('#connectionStatus').textContent = '⚠️ Connection failed';
      }
    }

    function isSameDay(a,b){ return a && b && a.getFullYear()===b.getFullYear() && a.getMonth()===b.getMonth() && a.getDate()===b.getDate(); }

    function renderClassesForDate(date, containerId) {
      const container = q('#' + containerId);
      const rows = [];
      for (let i=1; i<allSheetData.length; i++){
        const row = allSheetData[i] || [];
        if (!row[0] || !row[1]) continue;
        const classDate = parseDate(row[0]);
        if (!classDate || !isSameDay(classDate, date)) continue;
        // find class name from candidate columns
        let className = null;
        [2,9,10,11,3].forEach(idx => { if (!className && row[idx] && String(row[idx]).trim()) className = String(row[idx]).trim(); });
        if (!className) continue;
        if (enrolledClasses.length > 0) {
          const cn = className.toLowerCase();
          if (!enrolledClasses.some(s => cn.includes(String(s).toLowerCase()))) continue;
        }
        rows.push({ class: className, time: row[1], location: row[4] || '', professor: row[6] || 'N/A' });
      }
      if (rows.length === 0) {
        container.innerHTML = '<div style="padding:16px;color:#6b7280">No classes</div>';
      } else {
        container.innerHTML = rows.map(r => `<div style="padding:12px;border-bottom:1px solid #eef2f7"><div style="font-weight:700">${escapeHtml(r.class)}</div><div style="color:#475569;margin-top:6px">${escapeHtml(r.time)} • ${escapeHtml(r.location)} • Prof: ${escapeHtml(r.professor)}</div></div>`).join('');
      }
    }

    function renderTodayTomorrow() {
      const today = new Date();
      const tomorrow = new Date(); tomorrow.setDate(today.getDate()+1);
      renderClassesForDate(today, 'todayClasses');
      renderClassesForDate(tomorrow, 'upcomingClassesContainer');
    }

    // ---------------- ICS generation (unchanged) ----------------
    function generateMonthlyICS() {
      if (enrolledClasses.length === 0) { alert('Select subjects first'); return; }
      const termStart = new Date(2025,8,10), termEnd = new Date(2025,11,6);
      let icsHeader = [
        'BEGIN:VCALENDAR','VERSION:2.0','PRODID:-//StudentDashboard//AkshaySharma//EN','CALSCALE:GREGORIAN','METHOD:PUBLISH',
        'BEGIN:VTIMEZONE','TZID:Asia/Kolkata','BEGIN:STANDARD','DTSTART:19700101T000000','TZOFFSETFROM:+0530','TZOFFSETTO:+0530','TZNAME:IST','END:STANDARD','END:VTIMEZONE'
      ].join('\r\n') + '\r\n';
      let icsBody = '';
      let count = 0;
      for (let i=1;i<allSheetData.length;i++){
        const row = allSheetData[i] || [];
        if (!row[0] || !row[1]) continue;
        const classDate = parseDate(row[0]);
        if (!classDate || classDate < termStart || classDate > termEnd) continue;
        // subject
        let className = null;
        [2,9,10,11,3].forEach(idx => { if (!className && row[idx] && String(row[idx]).trim()) className = String(row[idx]).trim(); });
        if (!className) continue;
        if (enrolledClasses.length > 0) {
          const cn = className.toLowerCase();
          if (!enrolledClasses.some(s => cn.includes(String(s).toLowerCase()))) continue;
        }
        // parse time
        const timeParts = String(row[1]).split(/[-–—\u2013\u2014]|to/i).map(s=>s.trim()).filter(Boolean);
        if (timeParts.length < 2) continue;
        const startT = parseTimeString(timeParts[0]), endT = parseTimeString(timeParts[1]);
        if (!startT || !endT) continue;
        const startDate = new Date(classDate.getFullYear(), classDate.getMonth(), classDate.getDate(), startT.hours, startT.minutes);
        const endDate = new Date(classDate.getFullYear(), classDate.getMonth(), classDate.getDate(), endT.hours, endT.minutes);
        if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) continue;
        // stable UID: prefer a 'rowNN' value if present in the row, else fallback to row index
        let stable = null;
        for (const cell of row) {
          if (typeof cell === 'string' && /^row\d+/i.test(cell.trim())) { stable = cell.trim(); break; }
        }
        const uid = stable ? `${stable}@studentdashboard.com` : `r${i}-${className.replace(/\s+/g,'') }@studentdashboard.com`;
        const dtstamp = new Date().toISOString().replace(/[-:.]/g,'').slice(0,-4) + 'Z';
        const dtstart = `${startDate.getFullYear()}${pad2(startDate.getMonth()+1)}${pad2(startDate.getDate())}T${pad2(startDate.getHours())}${pad2(startDate.getMinutes())}00`;
        const dtend = `${endDate.getFullYear()}${pad2(endDate.getMonth()+1)}${pad2(endDate.getDate())}T${pad2(endDate.getHours())}${pad2(endDate.getMinutes())}00`;
        const description = `Professor: ${row[6] ? row[6] : 'N/A'}`;
        const location = row[4] ? row[4] : '';
        icsBody += [
          'BEGIN:VEVENT',
          `DTSTAMP:${dtstamp}`,
          `UID:${uid}`,
          `DTSTART;TZID=Asia/Kolkata:${dtstart}`,
          `DTEND;TZID=Asia/Kolkata:${dtend}`,
          `SUMMARY:${className}`,
          `DESCRIPTION:${description.replace(/\n/g,'\\n').replace(/,/g,'\\,')}`,
          `LOCATION:${location.replace(/,/g,'\\,')}`,
          'END:VEVENT'
        ].join('\r\n') + '\r\n';
        count++;
      }
      const ics = icsHeader + icsBody + 'END:VCALENDAR';
      if (count === 0) { alert('No classes found for selected subjects'); return; }
      const blob = new Blob([ics], { type: 'text/calendar;charset=utf-8' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'class_schedule.ics';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(a.href);
      alert('Generated ICS with ' + count + ' events');
    }

    // ---------------- Google Sync (kept robust, unchanged) ----------------
    // Basic token client init + wrappers. Keep CLIENT_ID replaced before testing.
    function initTokenClient() {
      if (!window.google || !google.accounts || !google.accounts.oauth2) return;
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: SCOPE,
        callback: (resp) => {
          tokenResponse = resp;
          if (pendingSyncFunction) { const fn = pendingSyncFunction; pendingSyncFunction = null; fn(); }
        }
      });
    }
    function requestGoogleToken() {
      if (!tokenClient) initTokenClient();
      tokenClient.requestAccessToken({ prompt: 'consent' });
    }
    async function gcalFetch(url, method='GET', body=null) {
      if (!tokenResponse || !tokenResponse.access_token) throw new Error('No access token');
      const headers = { Authorization: 'Bearer ' + tokenResponse.access_token };
      const opts = { method, headers };
      if (body) { headers['Content-Type'] = 'application/json'; opts.body = JSON.stringify(body); }
      const r = await fetch(url, opts);
      if (!r.ok) { const text = await r.text(); throw new Error('GCal API ' + r.status + ': ' + text); }
      if (r.status === 204) return {};
      return await r.json();
    }

    // helper row->event (for sync)
    function rowToEvent(row, rowIndex) {
      const rawDate = row[0], rawTime = row[1];
      const subjectCandidates = [row[2], row[9], row[10], row[11], row[3]];
      let className = null;
      for (const c of subjectCandidates) if (!className && c && String(c).trim()) className = String(c).trim();
      if (!rawDate || !rawTime || !className) return null;
      const dateObj = parseDate(rawDate);
      if (!dateObj) return null;
      const timeParts = String(rawTime).split(/[-–—\u2013\u2014]|to/i).map(s=>s.trim()).filter(Boolean);
      if (timeParts.length < 2) return null;
      const startT = parseTimeString(timeParts[0]), endT = parseTimeString(timeParts[1]);
      if (!startT || !endT) return null;
      const startDate = new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate(), startT.hours, startT.minutes);
      const endDate   = new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate(), endT.hours, endT.minutes);
      if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) return null;
      // stable external id
      let stable = null;
      for (const cell of row) if (typeof cell === 'string' && /^row\d+/i.test(cell.trim())) { stable = cell.trim(); break; }
      const externalId = stable ? stable : `r${rowIndex}-${className.replace(/\s+/g,'_').replace(/[^\w\-]/g,'').slice(0,30)}`;
      return {
        externalId,
        summary: className,
        description: `Professor: ${row[6] ? row[6] : 'N/A'}`,
        location: (row[4] || '').toString(),
        startRfc3339: toRFC3339_Kolkata(startDate),
        endRfc3339: toRFC3339_Kolkata(endDate)
      };
    }

    // wrappers for create/update/list/delete remote events — same approach as earlier guidance
    async function listMyEvents(timeMin, timeMax, pageToken=null) {
      const params = new URLSearchParams({ singleEvents:'true', maxResults:'2500', orderBy:'startTime' });
      if (timeMin) params.set('timeMin', timeMin);
      if (timeMax) params.set('timeMax', timeMax);
      params.set('privateExtendedProperty', encodeURIComponent('studentdashboard_owner=true'));
      if (pageToken) params.set('pageToken', pageToken);
      return await gcalFetch('https://www.googleapis.com/calendar/v3/calendars/primary/events?' + params.toString(), 'GET');
    }
    async function findEventByExternalId(externalId) {
      const param = encodeURIComponent(`studentdashboard_id=${externalId}`);
      const url = `https://www.googleapis.com/calendar/v3/calendars/primary/events?privateExtendedProperty=${param}&singleEvents=true&maxResults=1`;
      const res = await gcalFetch(url,'GET');
      return (res.items && res.items.length) ? res.items[0] : null;
    }
    async function createEventOnGoogle(event) {
      const body = { summary:event.summary, description:event.description||'', location:event.location||'', start:{dateTime:event.startRfc3339}, end:{dateTime:event.endRfc3339}, extendedProperties:{ private:{ studentdashboard_id:event.externalId, studentdashboard_owner:'true' } } };
      return await gcalFetch('https://www.googleapis.com/calendar/v3/calendars/primary/events','POST',body);
    }
    async function updateEventOnGoogle(eventId, event) {
      const body = { summary:event.summary, description:event.description||'', location:event.location||'', start:{dateTime:event.startRfc3339}, end:{dateTime:event.endRfc3339}, extendedProperties:{ private:{ studentdashboard_id:event.externalId, studentdashboard_owner:'true' } } };
      return await gcalFetch(`https://www.googleapis.com/calendar/v3/calendars/primary/events/${eventId}`,'PATCH',body);
    }
    async function deleteEventOnGoogle(eventId) { return await gcalFetch(`https://www.googleapis.com/calendar/v3/calendars/primary/events/${eventId}`,'DELETE'); }

    async function syncAllEventsToGoogle() {
      try {
        if (!tokenResponse || !tokenResponse.access_token) {
          pendingSyncFunction = syncAllEventsToGoogle;
          requestGoogleToken();
          return;
        }
        // build local events
        const localEvents = [];
        for (let i=1;i<allSheetData.length;i++){
          const ev = rowToEvent(allSheetData[i], i);
          if (!ev) continue;
          if (enrolledClasses.length > 0) {
            const cn = ev.summary.toLowerCase();
            if (!enrolledClasses.some(s => cn.includes(s.toLowerCase()))) continue;
          }
          localEvents.push(ev);
        }
        if (localEvents.length === 0) { alert('No events to sync'); return; }
        const minTime = localEvents.map(e => e.startRfc3339).reduce((a,b)=> a<b?a:b);
        const maxTime = localEvents.map(e => e.endRfc3339).reduce((a,b)=> a>b?a:b);
        // load remote events
        let remoteEvents = [], pageToken = null;
        do {
          const res = await listMyEvents(minTime, maxTime, pageToken);
          if (res.items && res.items.length) remoteEvents = remoteEvents.concat(res.items);
          pageToken = res.nextPageToken || null;
        } while (pageToken);
        const remoteMap = {};
        remoteEvents.forEach(ev => {
          const ext = ev.extendedProperties && ev.extendedProperties.private && ev.extendedProperties.private.studentdashboard_id;
          if (ext) remoteMap[ext] = ev;
        });
        const processed = new Set();
        for (const localEvent of localEvents) {
          const existing = remoteMap[localEvent.externalId];
          if (existing) {
            await updateEventOnGoogle(existing.id, localEvent);
          } else {
            await createEventOnGoogle(localEvent);
          }
          processed.add(localEvent.externalId);
          await new Promise(r => setTimeout(r, 120));
        }
        // delete remote leftovers
        for (const ext in remoteMap) {
          if (!processed.has(ext)) {
            await deleteEventOnGoogle(remoteMap[ext].id);
            await new Promise(r => setTimeout(r, 80));
          }
        }
        alert('Sync completed');
      } catch (err) {
        console.error('Sync error', err);
        alert('Sync failed: ' + (err.message || err));
      }
    }

    // ---------------- wiring ----------------
    refreshBtn.addEventListener('click', refreshData);
    downloadBtn.addEventListener('click', generateMonthlyICS);
    syncBtn.addEventListener('click', syncAllEventsToGoogle);

    // init google token client once google lib is ready
    const glInt = setInterval(() => {
      if (window.google && google.accounts && google.accounts.oauth2) {
        clearInterval(glInt);
        initTokenClient();
      }
    }, 250);

    // initial load
    refreshData();

    // expose requestGoogleToken globally for quick manual test (optional)
    window.requestGoogleToken = requestGoogleToken;

  })();
  </script>
</body>
</html>
